### Контест 2016

### Задача 1

Надо написать часть программы, которая умеет играть в карты. Карты в колоде из 52 карт можно хранить в виде структуры

```
struct Card {
    char rank;  // достоинство
    char suit;  // масть
}
```

Масти кодируются как `'c' (крести)`, `'s'(пики)`, `'h'(червы)`, `'d'(бубны)`.

Достоинство кодируется как `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `T (десять)`, `J (валет)`, `Q (дама)`, `K (король)`, `A (туз)`.

В этой нотации дама пик и король бубен записываются как `QsKd`.

Отсортируйте данные карты по возрастанию.

Карты одного достоинства сортировать по мастям в следующем порядке: `'c' (крести)`, `'s'(пики)`, `'h'(червы)`, `'d'(бубны)`.

##### Input

Целое число 0 < N <= 52. На другой строке набор карт в указанной нотации.

##### Output

Отсортированный набор карт в указанной нотации.

### Задача 2

Реализуйте структуру данных, которая может выполнять следующие две операции: PAINT(x, y, col) -- покрасить точку (x, y) в цвет col, QUERY(x, y) -- определить цвет точки (x, y).

Покрашенные точки могут быть красными или синими. Изначально все точки плоскости считаются непокрашенными. Известно, что размер любого множества точек, в котором совпадают остатки от деления координат x на 100019, не превосходит 100.

В первой строке входного файла содержится число запросов n (от 1 до 100000). В каждой из следующих n строк содержатся запросы. Запросы выполняются в том порядке, в котором они встречаются во входном файле. Разные запросы могут относиться к одной и той же точке (в частности, некоторые точки могут быть перекрашенными в процессе).

Запрос PAINT имеет вид 1 x y c, где x и y -- координаты точки, которую надо добавить (x и y от 1 до миллиарда), c -- символ, обозначающий цвет точки. Синие точки обозначаются символом B, красные -- R.

Запрос QUERY 2 x y, где x и y -- координаты точки, цвет которой необходимо узнать.

Для каждой операции типа QUERY выведите в отдельной строке B, если точка на момент запроса синяя, или R, если она красная. Если точка с указанными координатами ни разу не была покрашена, выведите N.

### Задача 3

Из верхнего левого угла в правый нижний угол сетки 2х2 можно пройти 6 разными путями. Сколько таких разных путей можно найти в сетке NxM?

##### Input

Целое число 1 <= N, M <= 20 через пробел.

##### Output

Количество разных путей.

### Задача 4

Неориентированный взвешенный граф без петель задан списком ребер, для каждого ребра указана его длина. Найдите кратчайшие расстояния от данной вершины графа до всех остальных.

##### Input

На первой строке задается число N (1 <= N <= 100) -- количество вершин в графе, и M (1 <= M <= N(N-1)/2) -- количество ребер. Затем следует M строк, в каждой из которых через пробел указывается 3 неотрицательных числа -- номера двух соединенных вершин графа и длина ребер (в указанном порядке). На последней строке указывается номер исходной вершины, от которой надо искать кратчайшие расстояния до всех остальных. Считаем, что вершины нумеруются с 0.

##### Output

Строка, в которой через пробел выводится N чисел -- кратчайшие расстояния до соответствующих вершин, в порядке увеличения номера вершины.

### Задача 5

Реализовать на С++ класс Matrix.

Публичные поля:
* rows -- количество строк
* сolumns -- количество столбцов
* double \*data -- данные матрицы (лежат в динамической памяти, к ним должен быть прямой доступ, данные лежат по строкам)

В том числе реализовать:
* конструктор Matrix(int rows, int columns)
* конструктор копирования
* оператор <<, который возвращает матрицу по строкам

Данные хранятся в памяти в виде массива, память под него выделяется динамически построчно, т.е. сначала идут элементы первой строки, затем элементы второй строки и т.д.

### Задача 6

Напишите программу, которая получает на вход слово "float", "double" или "long double", после которого идет действительное число и выводит его бинарное представление по 4 разряда

Примеры:
```
float 1
0011 1111 1000 0000 0000 0000 0000 0000

double -1
0000 0000 0000 0000 0000 0000 0000 0000 0000
```

Рекомендуется использовать union -- совместное использование одной и той же области памяти с интерпретацией как данные различных типов.
```
union u {
    char data[size];
    long double ldb;
    double db;
    float fl;
}
```

### Задача 7

Рассмотрим две квадратные матрицы A и B размера n.
```
A[i][j] = НОД(i+1, j+1)
B[i][j] = НОД(n-i+1, n-j+1)
```
где НОД(x, y) -- наибольший общий делитель чисел x и y. Выведите число элементов произведения матриц AB, которые делятся на заданное число d. 

### Задача 8

В вычислительной системе с сегментной организацией памяти и 32-х битовым адресом максимальный размер сегмента составляет X Mb.

a. Определите, сколько бит отводится для номера сегмента. А также, какое максимальное количество сегментов может использовать процесс.

b. Пусть для некоторого процесса дана таблица сегментов. Для каждого данного логического адреса вычислите соответствующий ему физический адрес.

##### Input

На первой строке идет десятичное число 0 < X < 4096 -- максимальный размер сегмента в мегабайтах. За ним через пробел следует десятичное число 0 < N < 100 -- количество записей в таблице сегментов.

На следующих N строках задается сама таблица сегментов, на каждой строке по одной записи. Для каждого сегмента указывается 3 числа: номер сегмента (десятичное), адрес начала (16-чное) и длина сегмента (16-чное).

Затем до завершения потока ввода, перечисляется произвольное число логических адресов (в 16-чной сс), каждое с новой строки.

### Задача 9

В IPv4 адрес компьютера состоит из 32 бит, которые для удобства могут быть записаны как 4 десятичных числа от 0 до 255, разделенные точками. С другой стороны, если IP адрес компьютера представить в двоичном виде, то N cтарших бит определяют адрес подсети, а остальные биты -- адрес компьютера внутри этой подсети. Сетевой маской такой подсети является тоже набор из 32 бит, в котором те N старших бит, сответствующих адресу подсети, установлены в 1, а соответствующие адресу компьютера -- в 0.

По введенным IP адресу и сетевой маске определите широковещательный адрес, в котором N старших бит -- адрес подсети, а остальные биты установлены в 1.

Пример
```
192.168.254.4
              -> 192.168.255.255
255.255.252.0
```

### Задача 10

Только java.

Найдите первые 10 цифр суммы нескольких 50-значных чисел.
